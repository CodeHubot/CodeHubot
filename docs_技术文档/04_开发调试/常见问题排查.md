# 常见问题排查指南

## 概述

本文档整理了 CodeHubot 项目开发和部署过程中的常见问题及解决方案，帮助快速定位和解决问题。适合教学和实际开发使用。

## 问题排查流程

```
1. 观察现象
   ├── 错误信息
   ├── 日志内容
   └── 异常行为

2. 定位问题
   ├── 前端问题？
   ├── 后端问题？
   ├── 数据库问题？
   ├── 网络问题？
   └── 配置问题？

3. 分析原因
   ├── 查看日志
   ├── 检查代码
   ├── 测试验证
   └── 查阅文档

4. 解决问题
   ├── 修复代码
   ├── 调整配置
   └── 重启服务

5. 验证结果
   └── 确认问题已解决
```

## 前端问题

### 1. 页面空白/白屏

**现象**：打开页面后显示空白

**可能原因**：
- JavaScript 错误
- 路由配置错误
- 组件挂载失败

**排查步骤**：

```javascript
// 1. 打开浏览器控制台（F12）
// 查看 Console 标签页是否有报错

// 2. 常见错误：
// - Uncaught TypeError: Cannot read property 'xxx' of undefined
// - Failed to compile
// - Module not found

// 3. 检查路由配置
// frontend/src/router/index.js
const routes = [
  {
    path: '/',
    component: Home  // 组件是否正确导入？
  }
]

// 4. 检查组件挂载
// main.js
import { createApp } from 'vue'
import App from './App.vue'

const app = createApp(App)
app.mount('#app')  // 确保 index.html 中有 id="app" 的元素
```

**解决方案**：

```bash
# 清除缓存并重新启动
rm -rf node_modules
rm package-lock.json
npm install
npm run dev
```

### 2. API 请求失败（Network Error）

**现象**：前端请求后端 API 失败

**可能原因**：
- 后端服务未启动
- CORS 跨域问题
- 请求地址错误
- Token 过期

**排查步骤**：

```javascript
// 1. 打开 Network 标签页，查看请求状态
// - Failed to fetch: 后端未启动或地址错误
// - 401: Token 过期或无效
// - 403: 权限不足
// - 404: 接口不存在
// - 500: 服务器内部错误

// 2. 检查后端是否启动
// 浏览器访问: http://localhost:8000/docs

// 3. 检查请求地址
console.log('请求地址:', axios.defaults.baseURL)

// 4. 检查 Token
const token = localStorage.getItem('access_token')
console.log('Token:', token)

// 5. 检查 CORS 配置
// backend/main.py
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],  // 前端地址
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

**解决方案**：

```javascript
// 方案1：检查并修正 API 基础地址
// vite.config.js
export default defineConfig({
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:8000',  // 确保地址正确
        changeOrigin: true
      }
    }
  }
})

// 方案2：刷新 Token
async function refreshToken() {
  const refreshToken = localStorage.getItem('refresh_token')
  const response = await axios.post('/api/auth/refresh', {
    refresh_token: refreshToken
  })
  localStorage.setItem('access_token', response.data.access_token)
}

// 方案3：重新登录
localStorage.clear()
router.push('/login')
```

### 3. 组件不更新（响应式失效）

**现象**：修改数据后，页面不更新

**可能原因**：
- 未使用响应式 API
- 直接修改数组/对象
- 异步更新时机问题

**排查步骤**：

```javascript
// ❌ 错误示例
export default {
  data() {
    return {
      user: null
    }
  },
  methods: {
    updateUser() {
      // 直接赋值新对象（Vue 2 中可能失效）
      this.user = { name: 'Alice' }
    }
  }
}

// ✅ 正确做法（Vue 3）
import { ref, reactive } from 'vue'

const user = ref(null)
const state = reactive({
  users: []
})

// 更新单个属性
user.value = { name: 'Alice' }

// 更新数组
state.users.push({ id: 1, name: 'Bob' })

// 替换整个数组
state.users = newUsers  // reactive 可以替换

// ⚠️ ref 需要 .value
const count = ref(0)
count.value++  // 正确
// count++  // 错误！
```

**解决方案**：

```javascript
// 使用 Vue 3 的响应式 API
import { ref, computed, watch } from 'vue'

const data = ref([])

// 修改数据
data.value = newData

// 监听变化
watch(data, (newVal) => {
  console.log('数据变化:', newVal)
})
```

### 4. Element Plus 组件样式不显示

**现象**：组件渲染了，但没有样式

**排查步骤**：

```javascript
// 1. 检查是否导入样式
// main.js
import 'element-plus/dist/index.css'

// 2. 检查是否正确导入组件
import { ElButton, ElMessage } from 'element-plus'

// 3. 自动导入（推荐）
// vite.config.js
import AutoImport from 'unplugin-auto-import/vite'
import Components from 'unplugin-vue-components/vite'
import { ElementPlusResolver } from 'unplugin-vue-components/resolvers'

export default {
  plugins: [
    AutoImport({
      resolvers: [ElementPlusResolver()],
    }),
    Components({
      resolvers: [ElementPlusResolver()],
    }),
  ],
}
```

## 后端问题

### 1. 服务启动失败

**现象**：运行 `uvicorn main:app` 失败

**可能原因**：
- 端口被占用
- 依赖包未安装
- 配置文件错误
- 数据库连接失败

**排查步骤**：

```bash
# 1. 查看错误信息
uvicorn main:app --reload

# 常见错误：
# - ModuleNotFoundError: No module named 'xxx'
# - Address already in use
# - OperationalError: (2003, "Can't connect to MySQL")

# 2. 检查端口占用
lsof -i:8000
# 或
netstat -an | grep 8000

# 3. 检查依赖
pip list | grep fastapi

# 4. 检查数据库连接
mysql -u root -p -e "SELECT 1"

# 5. 检查环境变量
cat backend/.env
```

**解决方案**：

```bash
# 方案1：更换端口
uvicorn main:app --port 8001

# 方案2：杀死占用进程
kill -9 <PID>

# 方案3：重装依赖
pip install -r requirements.txt

# 方案4：检查配置
# backend/.env
DB_HOST=localhost
DB_PORT=3306
DB_USER=root
DB_PASSWORD=your_password
DB_NAME=aiot_admin
```

### 2. 数据库连接失败

**现象**：
```
sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) 
(2003, "Can't connect to MySQL server on 'localhost'")
```

**排查步骤**：

```bash
# 1. 检查 MySQL 是否运行
# macOS
brew services list

# Linux
systemctl status mysql

# Docker
docker ps | grep mysql

# 2. 测试连接
mysql -h localhost -u root -p

# 3. 检查配置
# backend/.env
DB_HOST=localhost  # Docker 中应该是服务名
DB_PORT=3306
DB_USER=root
DB_PASSWORD=your_password

# 4. 检查网络
ping localhost
telnet localhost 3306
```

**解决方案**：

```bash
# 方案1：启动 MySQL
# macOS
brew services start mysql

# Docker
docker-compose up -d mysql

# 方案2：修改配置
# Docker 环境中
DB_HOST=mysql  # 使用服务名而不是 localhost

# 方案3：重置密码
mysql -u root
ALTER USER 'root'@'localhost' IDENTIFIED BY 'new_password';
FLUSH PRIVILEGES;
```

### 3. Token 验证失败（401 Unauthorized）

**现象**：API 请求返回 401 错误

**可能原因**：
- Token 过期
- Token 格式错误
- SECRET_KEY 不匹配
- Token 未正确发送

**排查步骤**：

```python
# 1. 检查 Token
import jwt

token = "YOUR_TOKEN"
try:
    payload = jwt.decode(token, "SECRET_KEY", algorithms=["HS256"])
    print("Token 有效:", payload)
except jwt.ExpiredSignatureError:
    print("Token 已过期")
except jwt.InvalidTokenError:
    print("Token 无效")

# 2. 检查请求头
# 前端
console.log('Authorization:', request.headers.Authorization)

# 后端
from fastapi import Request

@app.get("/test")
async def test(request: Request):
    print("Headers:", request.headers)
    auth = request.headers.get("Authorization")
    print("Auth:", auth)

# 3. 检查 SECRET_KEY
# backend/.env
SECRET_KEY=your-secret-key-must-be-same-everywhere

# 4. 检查过期时间
# backend/app/core/config.py
ACCESS_TOKEN_EXPIRE_MINUTES = 1440  # 24小时
```

**解决方案**：

```python
# 方案1：刷新 Token
async def refresh_token():
    refresh_token = localStorage.getItem('refresh_token')
    response = await axios.post('/api/auth/refresh', {
        refresh_token: refresh_token
    })
    localStorage.setItem('access_token', response.data.access_token)

# 方案2：检查 Token 格式
# 正确格式：Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
headers = {
    "Authorization": f"Bearer {token}"  # 注意 Bearer 前缀
}

# 方案3：统一 SECRET_KEY
# 确保所有服务使用相同的 SECRET_KEY
```

### 4. 导入错误（ModuleNotFoundError）

**现象**：
```
ModuleNotFoundError: No module named 'app'
```

**排查步骤**：

```bash
# 1. 检查当前目录
pwd
ls

# 2. 检查 Python 路径
python -c "import sys; print('\n'.join(sys.path))"

# 3. 检查模块是否存在
ls app/

# 4. 检查导入语句
# main.py
from app.api import api_router  # 相对于项目根目录
```

**解决方案**：

```bash
# 方案1：设置 PYTHONPATH
export PYTHONPATH=/path/to/project/backend:$PYTHONPATH

# 方案2：从正确的目录启动
cd backend
uvicorn main:app --reload

# 方案3：使用绝对导入
# 在 backend 目录下运行
python -m uvicorn main:app --reload
```

## 数据库问题

### 1. 表不存在

**现象**：
```
sqlalchemy.exc.ProgrammingError: (pymysql.err.ProgrammingError) 
(1146, "Table 'aiot_admin.core_users' doesn't exist")
```

**解决方案**：

```bash
# 方案1：执行初始化脚本
mysql -u root -p aiot_admin < SQL/init_database.sql

# 方案2：使用 SQLAlchemy 创建表
python
>>> from app.models import user
>>> from app.core.database import engine
>>> user.Base.metadata.create_all(bind=engine)

# 方案3：检查数据库
mysql -u root -p
USE aiot_admin;
SHOW TABLES;
```

### 2. 字符编码问题

**现象**：中文显示乱码

**解决方案**：

```sql
-- 检查数据库编码
SHOW VARIABLES LIKE 'character%';

-- 修改数据库编码
ALTER DATABASE aiot_admin CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- 修改表编码
ALTER TABLE core_users CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- 创建表时指定编码
CREATE TABLE users (
  id INT PRIMARY KEY,
  name VARCHAR(50)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

### 3. 外键约束失败

**现象**：
```
IntegrityError: (pymysql.err.IntegrityError) 
(1452, 'Cannot add or update a child row: a foreign key constraint fails')
```

**解决方案**：

```python
# 方案1：先创建父记录
# 先创建学校
school = School(name="测试学校")
db.add(school)
db.commit()

# 再创建用户
user = User(name="Alice", school_id=school.id)
db.add(user)
db.commit()

# 方案2：允许 NULL
# 修改模型
class User(Base):
    school_id = Column(Integer, ForeignKey('schools.id'), nullable=True)

# 方案3：级联删除
class User(Base):
    school = relationship('School', backref='users', 
                         cascade='all, delete-orphan')
```

## Docker 问题

### 1. 容器无法启动

**排查步骤**：

```bash
# 查看容器日志
docker logs codehubot-backend

# 查看容器状态
docker ps -a

# 进入容器
docker exec -it codehubot-backend bash

# 查看容器配置
docker inspect codehubot-backend
```

**常见问题**：

```bash
# 1. 端口冲突
# 修改 docker-compose.yml
ports:
  - "8001:8000"  # 改用 8001 端口

# 2. 卷挂载失败
# 检查路径是否存在
ls -la /path/to/volume

# 3. 环境变量缺失
# docker-compose.yml
environment:
  - DB_HOST=mysql
  - DB_PORT=3306
```

### 2. 网络连接问题

**现象**：容器间无法通信

**解决方案**：

```bash
# 检查网络
docker network ls
docker network inspect aiot-network

# 使用服务名而不是 localhost
DB_HOST=mysql  # 而不是 localhost
REDIS_HOST=redis

# 测试连接
docker exec codehubot-backend ping mysql
```

## 性能问题

### 1. API 响应慢

**排查步骤**：

```python
# 1. 添加计时
import time

@app.get("/devices")
async def get_devices():
    start = time.time()
    
    devices = db.query(Device).all()
    
    elapsed = time.time() - start
    print(f"查询耗时: {elapsed:.3f}秒")
    
    return devices

# 2. 查看 SQL 日志
import logging
logging.getLogger('sqlalchemy.engine').setLevel(logging.INFO)

# 3. 使用分析工具
from fastapi import Request
import time

@app.middleware("http")
async def add_process_time_header(request: Request, call_next):
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    response.headers["X-Process-Time"] = str(process_time)
    return response
```

**优化方案**：

```python
# 方案1：添加索引
# 数据库
CREATE INDEX idx_user_email ON core_users(email);

# SQLAlchemy
class User(Base):
    email = Column(String(100), unique=True, index=True)

# 方案2：使用缓存
from functools import lru_cache

@lru_cache(maxsize=100)
def get_config(key):
    return db.query(Config).filter(Config.key == key).first()

# 方案3：预加载关联
from sqlalchemy.orm import joinedload

users = db.query(User)\
    .options(joinedload(User.school))\
    .all()

# 方案4：分页
@app.get("/users")
def list_users(page: int = 1, size: int = 20):
    users = db.query(User)\
        .offset((page - 1) * size)\
        .limit(size)\
        .all()
    return users
```

## 教学要点总结

### 问题分类
1. **前端问题**：页面、组件、请求
2. **后端问题**：服务、API、数据库
3. **环境问题**：配置、依赖、网络
4. **性能问题**：慢查询、内存、并发

### 排查方法
1. **查看日志**：控制台、服务日志
2. **断点调试**：pdb、Chrome DevTools
3. **隔离问题**：最小复现
4. **查阅文档**：官方文档、Stack Overflow

### 预防措施
- ✅ 完善的错误处理
- ✅ 详细的日志记录
- ✅ 单元测试覆盖
- ✅ 代码审查

## 相关文档

- [调试技巧](./调试技巧.md) - 调试方法详解
- [本地开发环境](./本地开发环境.md) - 环境搭建
- [Docker容器化部署](../03_部署运维/Docker容器化部署.md) - 部署问题
