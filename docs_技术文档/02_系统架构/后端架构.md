# 后端架构设计

## 概述

CodeHubot 后端采用 FastAPI + SQLAlchemy + Pydantic 构建，使用分层架构和模块化设计，支持多业务模块和高并发场景。本文档详细介绍后端架构设计，适合教学和实际开发使用。

## 技术栈

### 核心框架

```python
fastapi==0.104.1          # Web 框架
uvicorn==0.24.0           # ASGI 服务器
sqlalchemy==2.0.23        # ORM 框架
pydantic==2.5.0           # 数据验证
pymysql==1.1.0            # MySQL 驱动
```

### 工具库

```python
python-jose[cryptography]==3.3.0   # JWT Token
passlib[bcrypt]==1.7.4             # 密码加密
redis==5.0.1                       # 缓存和队列
celery==5.3.4                      # 异步任务
paho-mqtt==2.0.0                   # MQTT 客户端
httpx==0.25.0                      # HTTP 客户端
aliyun-python-sdk-vod>=2.16.0      # 阿里云VOD
```

## 项目结构

```
backend/
├── app/
│   ├── main.py                      # 应用入口
│   │
│   ├── api/                         # API 路由层
│   │   ├── __init__.py              # 路由汇总
│   │   ├── auth.py                  # 认证接口
│   │   ├── devices.py               # 设备管理
│   │   ├── users.py                 # 用户管理
│   │   ├── ai/                      # AI 模块
│   │   │   ├── agents.py            # AI 助手
│   │   │   ├── chat.py              # 对话接口
│   │   │   ├── knowledge_bases.py   # 知识库
│   │   │   └── workflows.py         # 工作流
│   │
│   ├── core/                        # 核心配置
│   │   ├── config.py                # 配置管理
│   │   ├── security.py              # 安全工具
│   │   ├── deps.py                  # 依赖注入
│   │   ├── database.py              # 数据库连接
│   │   ├── response.py              # 统一响应
│   │   ├── logging_config.py        # 日志配置
│   │   └── celery_app.py            # Celery 配置
│   │
│   ├── models/                      # 数据模型（ORM）
│   │   ├── user.py                  # 用户模型
│   │   ├── device.py                # 设备模型
│   │   ├── agent.py                 # AI 助手模型
│   │   └── knowledge_base.py        # 知识库模型
│   │
│   ├── schemas/                     # 数据模式（Pydantic）
│   │   ├── user.py                  # 用户模式
│   │   ├── device.py                # 设备模式
│   │   ├── agent.py                 # AI 助手模式
│   │   └── ...                      # 其他模式
│   │
│   ├── services/                    # 业务逻辑层
│   │   ├── mqtt_service.py          # MQTT 服务
│   │   ├── llm_service.py           # 大模型服务
│   │   ├── embedding_service.py     # 向量化服务
│   │   ├── email.py                 # 邮件服务
│   │   └── workflow_executor.py     # 工作流执行器
│   │
│   ├── tasks/                       # 异步任务
│   │   ├── __init__.py
│   │   └── embedding_tasks.py       # 向量化任务
│   │
│   └── utils/                       # 工具函数
│       ├── device_helper.py         # 设备辅助
│       ├── document_parser.py       # 文档解析
│       └── excel_handler.py         # Excel 处理
│
├── requirements.txt                 # 依赖清单
├── Dockerfile                       # Docker 构建
└── .env                             # 环境配置
```

## 架构设计

### 分层架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    CodeHubot 后端架构                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │            API 路由层 (api/)                        │   │
│  │  ┌──────┐  ┌──────┐  ┌──────┐                      │   │
│  │  │ 认证 │  │ 设备 │  │  AI  │                      │   │
│  │  │ API  │  │ API  │  │ API  │                      │   │
│  │  └──────┘  └──────┘  └──────┘                      │   │
│  └─────────────┬───────────────────────────────────────┘   │
│                │                                            │
│  ┌─────────────┴───────────────────────────────────────┐   │
│  │         数据验证层 (schemas/)                       │   │
│  │  ┌─────────────────────────────────────────────┐    │   │
│  │  │  Pydantic 模型 - 请求/响应数据验证          │    │   │
│  │  └─────────────────────────────────────────────┘    │   │
│  └─────────────┬───────────────────────────────────────┘   │
│                │                                            │
│  ┌─────────────┴───────────────────────────────────────┐   │
│  │         业务逻辑层 (services/)                      │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐          │   │
│  │  │MQTT服务  │  │大模型服务│  │工作流    │          │   │
│  │  └──────────┘  └──────────┘  └──────────┘          │   │
│  └─────────────┬───────────────────────────────────────┘   │
│                │                                            │
│  ┌─────────────┴───────────────────────────────────────┐   │
│  │         数据访问层 (models/)                        │   │
│  │  ┌─────────────────────────────────────────────┐    │   │
│  │  │  SQLAlchemy ORM - 数据库操作                │    │   │
│  │  └─────────────────────────────────────────────┘    │   │
│  └─────────────┬───────────────────────────────────────┘   │
│                │                                            │
│  ┌─────────────┴───────────────────────────────────────┐   │
│  │              数据库层                               │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐          │   │
│  │  │  MySQL   │  │  Redis   │  │ Mosquitto│          │   │
│  │  │  数据库  │  │  缓存    │  │  MQTT    │          │   │
│  │  └──────────┘  └──────────┘  └──────────┘          │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │           横切关注点 (core/)                        │   │
│  │  认证授权 | 日志记录 | 异常处理 | 依赖注入         │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 请求处理流程

```
客户端请求
    ↓
┌────────────────────┐
│  中间件处理         │  (CORS, 日志, 异常)
└────────┬───────────┘
         ↓
┌────────────────────┐
│  路由匹配           │  (FastAPI Router)
└────────┬───────────┘
         ↓
┌────────────────────┐
│  依赖注入           │  (认证, 数据库会话)
└────────┬───────────┘
         ↓
┌────────────────────┐
│  数据验证           │  (Pydantic)
└────────┬───────────┘
         ↓
┌────────────────────┐
│  业务逻辑处理       │  (Services)
└────────┬───────────┘
         ↓
┌────────────────────┐
│  数据库操作         │  (SQLAlchemy)
└────────┬───────────┘
         ↓
┌────────────────────┐
│  响应序列化         │  (Pydantic)
└────────┬───────────┘
         ↓
返回客户端
```

## 核心配置

### 1. 应用入口 (main.py)

```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager

from app.core.config import settings
from app.core.response import CustomJSONResponse
from app.core.init_admin import init_admin
from app.core.init_defaults import init_defaults
from app.api import api_router

@asynccontextmanager
async def lifespan(app: FastAPI):
    """应用生命周期管理"""
    # 启动时执行
    print("应用启动中...")
    init_admin()        # 初始化管理员账号
    init_defaults()     # 初始化默认数据
    yield
    # 关闭时执行
    print("应用关闭中...")

# 创建 FastAPI 应用
app = FastAPI(
    title="CodeHubot API",
    description="AI-IoT 智能教学平台",
    version="1.0.0",
    lifespan=lifespan,
    default_response_class=CustomJSONResponse
)

# CORS 中间件
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # 生产环境应配置具体域名
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 注册路由
app.include_router(api_router, prefix="/api")

# 根路径
@app.get("/")
async def root():
    return {
        "message": "Welcome to CodeHubot API",
        "version": "1.0.0",
        "docs": "/docs"
    }

# 健康检查
@app.get("/health")
async def health():
    return {"status": "ok"}
```

### 2. 配置管理 (core/config.py)

```python
from pydantic_settings import BaseSettings
from typing import List

class Settings(BaseSettings):
    """应用配置"""
    
    # 基础配置
    APP_NAME: str = "CodeHubot"
    DEBUG: bool = False
    
    # 数据库配置
    DB_HOST: str = "localhost"
    DB_PORT: int = 3306
    DB_USER: str = "root"
    DB_PASSWORD: str = ""
    DB_NAME: str = "aiot_admin"
    
    @property
    def DATABASE_URL(self) -> str:
        return f"mysql+pymysql://{self.DB_USER}:{self.DB_PASSWORD}@{self.DB_HOST}:{self.DB_PORT}/{self.DB_NAME}"
    
    # Redis 配置
    REDIS_HOST: str = "localhost"
    REDIS_PORT: int = 6379
    REDIS_DB: int = 0
    REDIS_PASSWORD: str = ""
    
    # JWT 配置
    SECRET_KEY: str = "your-secret-key-change-in-production"
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 1440  # 24小时
    REFRESH_TOKEN_EXPIRE_DAYS: int = 30      # 30天
    
    # MQTT 配置
    MQTT_BROKER: str = "localhost"
    MQTT_PORT: int = 1883
    MQTT_USERNAME: str = ""
    MQTT_PASSWORD: str = ""
    
    # Celery 配置
    CELERY_BROKER_URL: str = "redis://localhost:6379/0"
    CELERY_RESULT_BACKEND: str = "redis://localhost:6379/1"
    
    # 大模型配置
    OPENAI_API_KEY: str = ""
    OPENAI_BASE_URL: str = "https://api.openai.com/v1"
    
    # 文件上传配置
    UPLOAD_DIR: str = "uploads"
    MAX_UPLOAD_SIZE: int = 10 * 1024 * 1024  # 10MB
    
    # CORS 配置
    ALLOWED_ORIGINS: List[str] = ["http://localhost:3000"]
    
    class Config:
        env_file = ".env"
        case_sensitive = True

settings = Settings()
```

### 3. 数据库连接 (core/database.py)

```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base
from app.core.config import settings

# 创建数据库引擎
engine = create_engine(
    settings.DATABASE_URL,
    pool_pre_ping=True,        # 连接池预检查
    pool_size=10,               # 连接池大小
    max_overflow=20,            # 最大溢出连接
    pool_recycle=3600,          # 连接回收时间（秒）
    echo=settings.DEBUG         # SQL 日志
)

# 创建会话工厂
SessionLocal = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=engine
)

# 声明基类
Base = declarative_base()

def get_db():
    """获取数据库会话（依赖注入）"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

### 4. 依赖注入 (core/deps.py)

```python
from typing import Optional
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.orm import Session

from app.core.database import get_db
from app.core.security import verify_token
from app.models.user import User

# OAuth2 方案
oauth2_scheme = OAuth2PasswordBearer(
    tokenUrl="api/auth/login",
    auto_error=False
)

async def get_current_user(
    token: Optional[str] = Depends(oauth2_scheme),
    db: Session = Depends(get_db)
) -> User:
    """获取当前登录用户"""
    if not token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="未提供认证令牌"
        )
    
    try:
        # 验证 Token
        payload = verify_token(token, "access")
        user_id = payload.get("sub")
        
        if not user_id:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="无效的令牌"
            )
        
        # 查询用户
        user = db.query(User).filter(User.id == int(user_id)).first()
        
        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="用户不存在"
            )
        
        if not user.active:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="用户已被禁用"
            )
        
        return user
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=str(e)
        )

async def get_current_admin(
    current_user: User = Depends(get_current_user)
) -> User:
    """获取当前管理员用户"""
    if current_user.role != "admin":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="需要管理员权限"
        )
    return current_user

async def get_current_user_flexible(
    roles: list[str],
    current_user: User = Depends(get_current_user)
) -> User:
    """灵活的角色验证"""
    if current_user.role not in roles:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=f"需要以下角色之一: {', '.join(roles)}"
        )
    return current_user
```

## API 路由设计

### 路由组织

```python
# api/__init__.py
from fastapi import APIRouter
from app.api import auth, devices, users
from app.api.ai import router as ai_router

api_router = APIRouter()

# 认证路由
api_router.include_router(
    auth.router, 
    prefix="/auth", 
    tags=["认证"]
)

# 设备管理路由
api_router.include_router(
    devices.router, 
    prefix="/devices", 
    tags=["设备管理"]
)

# 用户管理路由
api_router.include_router(
    users.router, 
    prefix="/users", 
    tags=["用户管理"]
)

# AI 系统路由
api_router.include_router(
    ai_router, 
    prefix="/ai", 
    tags=["AI智能系统"]
)
```

### 路由示例

```python
# api/devices.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from typing import List

from app.core.deps import get_db, get_current_user
from app.models.user import User
from app.models.device import Device
from app.schemas.device import DeviceCreate, DeviceUpdate, DeviceResponse

router = APIRouter()

@router.get("/", response_model=List[DeviceResponse])
async def list_devices(
    skip: int = 0,
    limit: int = 20,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """获取设备列表"""
    query = db.query(Device)
    
    # 非管理员只能看自己的设备
    if current_user.role != "admin":
        query = query.filter(Device.owner_id == current_user.id)
    
    devices = query.offset(skip).limit(limit).all()
    return devices

@router.post("/", response_model=DeviceResponse)
async def create_device(
    device_in: DeviceCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """创建设备"""
    device = Device(
        **device_in.dict(),
        owner_id=current_user.id
    )
    db.add(device)
    db.commit()
    db.refresh(device)
    return device

@router.get("/{device_id}", response_model=DeviceResponse)
async def get_device(
    device_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """获取设备详情"""
    device = db.query(Device).filter(Device.id == device_id).first()
    
    if not device:
        raise HTTPException(status_code=404, detail="设备不存在")
    
    # 权限检查
    if current_user.role != "admin" and device.owner_id != current_user.id:
        raise HTTPException(status_code=403, detail="无权访问")
    
    return device

@router.put("/{device_id}", response_model=DeviceResponse)
async def update_device(
    device_id: int,
    device_in: DeviceUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """更新设备"""
    device = db.query(Device).filter(Device.id == device_id).first()
    
    if not device:
        raise HTTPException(status_code=404, detail="设备不存在")
    
    # 权限检查
    if current_user.role != "admin" and device.owner_id != current_user.id:
        raise HTTPException(status_code=403, detail="无权修改")
    
    # 更新字段
    for field, value in device_in.dict(exclude_unset=True).items():
        setattr(device, field, value)
    
    db.commit()
    db.refresh(device)
    return device

@router.delete("/{device_id}")
async def delete_device(
    device_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """删除设备"""
    device = db.query(Device).filter(Device.id == device_id).first()
    
    if not device:
        raise HTTPException(status_code=404, detail="设备不存在")
    
    # 权限检查
    if current_user.role != "admin" and device.owner_id != current_user.id:
        raise HTTPException(status_code=403, detail="无权删除")
    
    db.delete(device)
    db.commit()
    return {"message": "删除成功"}
```

## 数据模型设计

### ORM 模型示例

```python
# models/device.py
from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey, Text
from sqlalchemy.orm import relationship
from datetime import datetime

from app.core.database import Base

class Device(Base):
    """设备模型"""
    __tablename__ = "devices"
    
    # 主键
    id = Column(Integer, primary_key=True, index=True)
    uuid = Column(String(36), unique=True, index=True, nullable=False)
    
    # 基本信息
    name = Column(String(100), nullable=False)
    device_type = Column(String(50), nullable=False)
    description = Column(Text, nullable=True)
    
    # 状态信息
    online = Column(Boolean, default=False)
    last_seen = Column(DateTime, nullable=True)
    
    # 配置信息
    config = Column(Text, nullable=True)  # JSON 配置
    
    # 关联关系
    owner_id = Column(Integer, ForeignKey('users.id'), nullable=False)
    owner = relationship("User", back_populates="devices")
    
    product_id = Column(Integer, ForeignKey('products.id'), nullable=True)
    product = relationship("Product")
    
    # 时间戳
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    def __repr__(self):
        return f"<Device(name='{self.name}', type='{self.device_type}')>"
```

### Pydantic 模式示例

```python
# schemas/device.py
from pydantic import BaseModel, Field
from typing import Optional
from datetime import datetime

class DeviceBase(BaseModel):
    """设备基础模式"""
    name: str = Field(..., min_length=1, max_length=100)
    device_type: str = Field(..., min_length=1, max_length=50)
    description: Optional[str] = None

class DeviceCreate(DeviceBase):
    """创建设备模式"""
    product_id: Optional[int] = None

class DeviceUpdate(BaseModel):
    """更新设备模式"""
    name: Optional[str] = Field(None, min_length=1, max_length=100)
    device_type: Optional[str] = Field(None, min_length=1, max_length=50)
    description: Optional[str] = None
    config: Optional[str] = None

class DeviceResponse(DeviceBase):
    """设备响应模式"""
    id: int
    uuid: str
    online: bool
    last_seen: Optional[datetime]
    owner_id: int
    product_id: Optional[int]
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True  # Pydantic v2
```

## 业务服务层

### 服务示例

```python
# services/mqtt_service.py
import paho.mqtt.client as mqtt
from app.core.config import settings
from app.core.database import SessionLocal
from app.models.device import Device

class MQTTService:
    """MQTT 服务"""
    
    def __init__(self):
        self.client = mqtt.Client()
        self.client.username_pw_set(
            settings.MQTT_USERNAME,
            settings.MQTT_PASSWORD
        )
        self.client.on_connect = self.on_connect
        self.client.on_message = self.on_message
        
    def connect(self):
        """连接 MQTT Broker"""
        self.client.connect(
            settings.MQTT_BROKER,
            settings.MQTT_PORT,
            60
        )
        self.client.loop_start()
    
    def on_connect(self, client, userdata, flags, rc):
        """连接回调"""
        print(f"MQTT 连接成功: {rc}")
        # 订阅设备主题
        client.subscribe("devices/+/status")
        client.subscribe("devices/+/data")
    
    def on_message(self, client, userdata, msg):
        """消息回调"""
        topic = msg.topic
        payload = msg.payload.decode()
        
        # 解析主题
        parts = topic.split('/')
        if len(parts) >= 3:
            device_uuid = parts[1]
            message_type = parts[2]
            
            # 处理消息
            if message_type == "status":
                self.handle_status(device_uuid, payload)
            elif message_type == "data":
                self.handle_data(device_uuid, payload)
    
    def handle_status(self, device_uuid, payload):
        """处理设备状态"""
        db = SessionLocal()
        try:
            device = db.query(Device).filter(
                Device.uuid == device_uuid
            ).first()
            
            if device:
                import json
                status = json.loads(payload)
                device.online = status.get('online', False)
                device.last_seen = datetime.utcnow()
                db.commit()
        finally:
            db.close()
    
    def publish(self, topic, payload):
        """发布消息"""
        self.client.publish(topic, payload)

# 单例
mqtt_service = MQTTService()
```

## 异步任务

```python
# tasks/embedding_tasks.py
from celery import Task
from app.core.celery_app import celery_app
from app.services.embedding_service import EmbeddingService
from app.core.database import SessionLocal
from app.models.document import Document

class CallbackTask(Task):
    """任务基类"""
    def on_success(self, retval, task_id, args, kwargs):
        print(f"任务 {task_id} 成功")
    
    def on_failure(self, exc, task_id, args, kwargs, einfo):
        print(f"任务 {task_id} 失败: {exc}")

@celery_app.task(base=CallbackTask, bind=True, max_retries=3)
def vectorize_document(self, document_id: int):
    """文档向量化任务"""
    db = SessionLocal()
    
    try:
        # 获取文档
        document = db.query(Document).filter(
            Document.id == document_id
        ).first()
        
        if not document:
            return {"error": "文档不存在"}
        
        # 更新状态
        document.embedding_status = 'processing'
        db.commit()
        
        # 向量化
        service = EmbeddingService()
        chunks = service.chunk_document(document.content)
        
        total = len(chunks)
        for i, chunk in enumerate(chunks):
            vector = service.generate_embedding(chunk)
            service.save_embedding(document_id, chunk, vector)
            
            # 更新进度
            self.update_state(
                state='PROGRESS',
                meta={'current': i + 1, 'total': total}
            )
        
        # 完成
        document.embedding_status = 'completed'
        document.chunk_count = total
        db.commit()
        
        return {"success": True, "chunks": total}
        
    except Exception as exc:
        document.embedding_status = 'failed'
        db.commit()
        raise self.retry(exc=exc, countdown=60)
        
    finally:
        db.close()
```

## 统一响应格式

```python
# core/response.py
from fastapi.responses import JSONResponse
from typing import Any, Optional

class CustomJSONResponse(JSONResponse):
    """自定义 JSON 响应"""
    
    @staticmethod
    def success(
        data: Any = None,
        message: str = "操作成功",
        code: int = 200
    ) -> dict:
        """成功响应"""
        return {
            "success": True,
            "code": code,
            "message": message,
            "data": data
        }
    
    @staticmethod
    def error(
        message: str = "操作失败",
        code: int = 400,
        data: Any = None
    ) -> dict:
        """失败响应"""
        return {
            "success": False,
            "code": code,
            "message": message,
            "data": data
        }
```

## 教学要点总结

### 核心概念
1. **分层架构**: API → Service → Model
2. **依赖注入**: FastAPI Depends
3. **数据验证**: Pydantic 模式
4. **ORM 映射**: SQLAlchemy 模型
5. **异步任务**: Celery 后台任务

### 设计原则
- ✅ 单一职责（每层职责明确）
- ✅ 依赖倒置（依赖抽象不依赖具体）
- ✅ 开闭原则（对扩展开放，对修改关闭）
- ✅ 接口隔离（细粒度接口）

### 适合讲授
- Python Web 开发
- 后端架构设计
- RESTful API 设计
- 数据库设计
- 异步编程

## 相关文档

- [FastAPI框架](../05_核心技术/FastAPI框架.md) - FastAPI 详解
- [SQLAlchemy-ORM](../05_核心技术/SQLAlchemy-ORM.md) - ORM 使用
- [Pydantic数据验证](../05_核心技术/Pydantic数据验证.md) - 数据验证
- [Celery异步任务](../05_核心技术/Celery异步任务.md) - 异步任务
- [整体架构设计](./整体架构设计.md) - 系统架构
