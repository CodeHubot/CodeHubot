# 权限管理体系

## 概述

CodeHubot 平台采用基于**角色的访问控制（RBAC）**模型,结合 JWT Token 实现统一的权限管理体系。系统支持多种用户角色，每种角色有不同的权限范围。

## 角色体系

### 角色定义

| 角色代码 | 角色名称 | 权限范围 | 使用场景 |
|---------|---------|---------|---------|
| `admin` | 系统管理员 | 全局管理权限 | 平台维护、用户管理、系统配置 |
| `channel` | 渠道管理员 | 管理下属学校 | 教育局、培训机构 |
| `teacher` | 教师 | 管理班级和学生 | 课程管理、作业批改 |
| `student` | 学生 | 访问学习资源 | 上课、提交作业 |
| `individual` | 独立用户 | 个人设备管理 | 个人项目开发 |

### 角色层级

```
System Admin (系统管理员)
    ↓ 管理
Channel Admin (渠道管理员)
    ↓ 管理
School (学校)
    ↓ 管理
Teacher (教师)
    ↓ 管理
Class (班级)
    ↓ 包含
Student (学生)

Independent User (独立用户) ← 独立存在，不属于任何组织
```

## 权限检查机制

### 1. Token 级别权限

#### 角色信息存储

登录时将角色信息编码到 JWT Token 中：

```python
# 生成 Token 时包含角色
access_token = create_access_token(
    data={
        "sub": str(user.id),
        "role": user.role,        # 用户角色
        "school_id": user.school_id,  # 所属机构
        "type": "access"
    }
)
```

#### 从 Token 提取角色

```python
async def get_current_user(token: str = Depends(oauth2_scheme)) -> User:
    """获取当前用户"""
    payload = verify_token(token, token_type="access")
    user_id = payload.get("sub")
    role = payload.get("role")
    
    # 查询用户并验证
    user = db.query(User).filter(User.id == int(user_id)).first()
    return user
```

### 2. 路由级别权限

#### 管理员权限依赖

**文件位置**: `backend/app/core/deps.py`

```python
async def get_current_admin(
    token: str = Depends(oauth2_scheme),
    db: Session = Depends(get_db)
) -> User:
    """获取当前管理员（必须是 admin 角色）"""
    user = await get_current_user(token, db)
    
    # 检查是否为管理员
    if user.role != 'admin':
        raise HTTPException(
            status_code=403,
            detail="需要管理员权限"
        )
    
    return user
```

#### 教师权限依赖

```python
async def get_current_teacher(
    token: str = Depends(oauth2_scheme),
    db: Session = Depends(get_db)
) -> User:
    """获取当前教师"""
    user = await get_current_user(token, db)
    
    if user.role != 'teacher':
        raise HTTPException(
            status_code=403,
            detail="需要教师权限"
        )
    
    return user
```

#### 在路由中使用

```python
from fastapi import APIRouter, Depends
from app.core.deps import get_current_admin, get_current_teacher

router = APIRouter()

# 仅管理员可访问
@router.get("/admin/users")
async def list_users(
    admin: User = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """获取所有用户（仅管理员）"""
    users = db.query(User).all()
    return {"users": users}

# 仅教师可访问
@router.get("/teacher/classes")
async def list_classes(
    teacher: User = Depends(get_current_teacher),
    db: Session = Depends(get_db)
):
    """获取教师的班级列表"""
    classes = db.query(Class).filter(
        Class.teacher_id == teacher.id
    ).all()
    return {"classes": classes}
```

### 3. 灵活权限依赖

对于需要多角色访问的接口：

```python
async def get_current_user_flexible(
    token: str = Depends(oauth2_scheme),
    db: Session = Depends(get_db)
) -> User:
    """灵活获取当前用户（支持多角色）"""
    return await get_current_user(token, db)

# 多角色可访问
@router.get("/courses")
async def list_courses(
    user: User = Depends(get_current_user_flexible),
    db: Session = Depends(get_db)
):
    """获取课程列表（教师和学生都可访问）"""
    if user.role == 'teacher':
        # 教师看自己创建的课程
        courses = db.query(Course).filter(
            Course.teacher_id == user.id
        ).all()
    elif user.role == 'student':
        # 学生看自己加入的课程
        courses = db.query(Course).join(...).filter(
            Student.id == user.id
        ).all()
    else:
        courses = []
    
    return {"courses": courses}
```

## 数据级别权限

### 1. 资源所有权检查

确保用户只能访问自己的资源：

```python
@router.get("/devices/{device_id}")
async def get_device(
    device_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """获取设备详情"""
    device = db.query(Device).filter(Device.id == device_id).first()
    
    if not device:
        raise HTTPException(status_code=404, detail="设备不存在")
    
    # 检查所有权
    if device.user_id != current_user.id:
        raise HTTPException(status_code=403, detail="无权访问此设备")
    
    return device
```

### 2. 组织层级权限

#### 渠道管理员权限

渠道管理员可以管理下属所有学校：

```python
async def verify_channel_permission(
    channel_admin: User,
    school_id: int,
    db: Session
):
    """验证渠道管理员对学校的权限"""
    if channel_admin.role != 'channel':
        raise HTTPException(status_code=403, detail="需要渠道管理员权限")
    
    school = db.query(School).filter(School.id == school_id).first()
    if not school or school.channel_id != channel_admin.id:
        raise HTTPException(status_code=403, detail="无权管理此学校")
```

#### 教师权限

教师只能管理自己的班级和学生：

```python
async def verify_teacher_class_permission(
    teacher: User,
    class_id: int,
    db: Session
):
    """验证教师对班级的权限"""
    class_obj = db.query(Class).filter(Class.id == class_id).first()
    
    if not class_obj:
        raise HTTPException(status_code=404, detail="班级不存在")
    
    if class_obj.teacher_id != teacher.id:
        raise HTTPException(status_code=403, detail="无权管理此班级")
```


## 前端权限控制

### 1. 路由守卫

**文件位置**: `frontend/src/router/index.js`

```javascript
import { createRouter, createWebHistory } from 'vue-router'

const router = createRouter({
  history: createWebHistory(),
  routes: [...]
})

// 全局前置守卫
router.beforeEach((to, from, next) => {
  // 检查是否需要认证
  if (to.meta.requiresAuth) {
    const token = localStorage.getItem('admin_access_token')
    
    if (!token) {
      // 未登录，跳转到登录页
      next('/admin/login')
      return
    }
  }
  
  // 检查角色权限
  if (to.meta.roles) {
    const userInfo = JSON.parse(localStorage.getItem('admin_user_info') || '{}')
    const userRole = userInfo.role
    
    if (!to.meta.roles.includes(userRole)) {
      // 角色不匹配，跳转到403页面
      next('/403')
      return
    }
  }
  
  next()
})
```

### 2. 路由配置

```javascript
const routes = [
  {
    path: '/admin',
    component: AdminLayout,
    meta: { requiresAuth: true, roles: ['admin'] },  // 仅管理员
    children: [
      {
        path: 'users',
        component: UserManagement,
        meta: { requiresAuth: true, roles: ['admin'] }
      }
    ]
  },
  {
    path: '/teacher',
    component: TeacherLayout,
    meta: { requiresAuth: true, roles: ['teacher'] },  // 仅教师
    children: [
      {
        path: 'classes',
        component: ClassManagement,
        meta: { requiresAuth: true, roles: ['teacher'] }
      }
    ]
  },
  {
    path: '/student',
    component: StudentLayout,
    meta: { requiresAuth: true, roles: ['student'] },  // 仅学生
    children: [
      {
        path: 'courses',
        component: MyCourses,
        meta: { requiresAuth: true, roles: ['student'] }
      }
    ]
  }
]
```

### 3. 按钮级权限控制

使用自定义指令控制按钮显示：

```javascript
// 权限指令
app.directive('permission', {
  mounted(el, binding) {
    const { value } = binding
    const userInfo = JSON.parse(localStorage.getItem('admin_user_info') || '{}')
    const userRole = userInfo.role
    
    if (value && !value.includes(userRole)) {
      // 移除元素
      el.parentNode?.removeChild(el)
    }
  }
})
```

使用示例：

```vue
<template>
  <!-- 仅管理员可见 -->
  <el-button v-permission="['admin']" @click="deleteUser">
    删除用户
  </el-button>
  
  <!-- 教师和管理员可见 -->
  <el-button v-permission="['admin', 'teacher']" @click="editClass">
    编辑班级
  </el-button>
</template>
```

### 4. 组件级权限

使用组合式 API 检查权限：

```javascript
// composables/usePermission.js
import { computed } from 'vue'

export function usePermission() {
  const userInfo = computed(() => {
    const info = localStorage.getItem('admin_user_info')
    return info ? JSON.parse(info) : {}
  })
  
  const userRole = computed(() => userInfo.value.role)
  
  const hasPermission = (roles) => {
    return roles.includes(userRole.value)
  }
  
  const isAdmin = computed(() => userRole.value === 'admin')
  const isTeacher = computed(() => userRole.value === 'teacher')
  const isStudent = computed(() => userRole.value === 'student')
  
  return {
    userInfo,
    userRole,
    hasPermission,
    isAdmin,
    isTeacher,
    isStudent
  }
}
```

在组件中使用：

```vue
<script setup>
import { usePermission } from '@/composables/usePermission'

const { isAdmin, isTeacher, hasPermission } = usePermission()
</script>

<template>
  <div>
    <!-- 仅管理员可见 -->
    <div v-if="isAdmin">
      <h2>管理员功能</h2>
    </div>
    
    <!-- 教师和管理员可见 -->
    <div v-if="hasPermission(['admin', 'teacher'])">
      <h2>教学管理</h2>
    </div>
  </div>
</template>
```

## API 权限矩阵

### 用户管理 API

| API 端点 | 方法 | 管理员 | 渠道 | 教师 | 学生 | 独立用户 |
|---------|------|--------|------|------|------|---------|
| `/api/users` | GET | ✅ | ❌ | ❌ | ❌ | ❌ |
| `/api/users/{id}` | GET | ✅ | ⚠️ | ⚠️ | ⚠️ | ⚠️ |
| `/api/users` | POST | ✅ | ❌ | ❌ | ❌ | ❌ |
| `/api/users/{id}` | PUT | ✅ | ⚠️ | ⚠️ | ⚠️ | ⚠️ |
| `/api/users/{id}` | DELETE | ✅ | ❌ | ❌ | ❌ | ❌ |

> ⚠️ 表示仅可访问自己的资源


### 设备管理 API

| API 端点 | 方法 | 管理员 | 渠道 | 教师 | 学生 | 独立用户 |
|---------|------|--------|------|------|------|---------|
| `/api/devices` | GET | ✅ | ❌ | ⚠️ | ⚠️ | ✅ |
| `/api/devices` | POST | ✅ | ❌ | ✅ | ❌ | ✅ |
| `/api/devices/{id}` | GET | ✅ | ❌ | ⚠️ | ⚠️ | ⚠️ |
| `/api/devices/{id}` | PUT | ✅ | ❌ | ⚠️ | ❌ | ⚠️ |
| `/api/devices/{id}` | DELETE | ✅ | ❌ | ⚠️ | ❌ | ⚠️ |

## 权限验证装饰器

### 自定义权限装饰器

```python
from functools import wraps
from fastapi import HTTPException

def require_roles(*allowed_roles):
    """角色权限装饰器"""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, current_user: User = None, **kwargs):
            if not current_user:
                raise HTTPException(status_code=401, detail="未认证")
            
            if current_user.role not in allowed_roles:
                raise HTTPException(
                    status_code=403,
                    detail=f"需要以下角色之一: {', '.join(allowed_roles)}"
                )
            
            return await func(*args, current_user=current_user, **kwargs)
        return wrapper
    return decorator
```

使用示例：

```python
@router.get("/admin/dashboard")
@require_roles('admin')
async def admin_dashboard(
    current_user: User = Depends(get_current_user)
):
    """管理员仪表板"""
    return {"message": "欢迎管理员"}
```

## 权限缓存优化

对于频繁检查的权限，可以使用 Redis 缓存：

```python
import redis
import json

redis_client = redis.Redis(host='localhost', port=6379, db=0)

def cache_user_permissions(user_id: int, permissions: list):
    """缓存用户权限"""
    key = f"user_permissions:{user_id}"
    redis_client.setex(key, 3600, json.dumps(permissions))  # 1小时

def get_cached_permissions(user_id: int) -> list:
    """获取缓存的权限"""
    key = f"user_permissions:{user_id}"
    data = redis_client.get(key)
    return json.loads(data) if data else None
```

## 安全最佳实践

### 1. 最小权限原则

- ✅ 默认拒绝所有访问
- ✅ 仅授予必要的最小权限
- ✅ 定期审查权限配置

### 2. 权限验证位置

```python
# ✅ 在服务端验证（必须）
@router.delete("/users/{user_id}")
async def delete_user(
    user_id: int,
    admin: User = Depends(get_current_admin)  # 服务端验证
):
    pass

# ❌ 仅在前端验证（不安全）
# 攻击者可以直接调用 API 绕过前端检查
```

### 3. 敏感操作二次验证

```python
@router.delete("/users/{user_id}")
async def delete_user(
    user_id: int,
    password: str,  # 要求再次输入密码
    admin: User = Depends(get_current_admin)
):
    """删除用户（需要二次确认）"""
    if not verify_password(password, admin.password_hash):
        raise HTTPException(status_code=401, detail="密码错误")
    
    # 执行删除
    ...
```

### 4. 操作日志记录

```python
def log_permission_check(user: User, resource: str, action: str, allowed: bool):
    """记录权限检查"""
    logger.info(
        f"权限检查: 用户={user.id} 资源={resource} "
        f"操作={action} 结果={'允许' if allowed else '拒绝'}"
    )
```

## 常见问题

### 1. 如何实现细粒度权限？

使用权限位图：

```python
class Permission(IntEnum):
    READ = 1       # 0001
    WRITE = 2      # 0010
    DELETE = 4     # 0100
    ADMIN = 8      # 1000

class User(Base):
    permissions: int = Column(Integer, default=Permission.READ)

def has_permission(user: User, permission: Permission) -> bool:
    return (user.permissions & permission) == permission

# 授予多个权限
user.permissions = Permission.READ | Permission.WRITE

# 检查权限
if has_permission(user, Permission.DELETE):
    # 允许删除
    pass
```

### 2. 如何处理跨组织访问？

使用访问令牌：

```python
class AccessToken(Base):
    """资源访问令牌"""
    token: str = Column(String(64), unique=True)
    resource_type: str = Column(String(50))
    resource_id: int = Column(Integer)
    expires_at: datetime = Column(DateTime)
```

### 3. 如何实现临时权限？

```python
class TemporaryPermission(Base):
    """临时权限"""
    user_id: int
    permission: str
    expires_at: datetime
    
def grant_temporary_permission(user_id: int, permission: str, duration: timedelta):
    """授予临时权限"""
    temp_perm = TemporaryPermission(
        user_id=user_id,
        permission=permission,
        expires_at=datetime.utcnow() + duration
    )
    db.add(temp_perm)
    db.commit()
```

## 相关文档

- [登录登出机制](./登录登出机制.md) - 认证流程
- [Token管理](./Token管理.md) - JWT Token 详解
- [API开发规范](../../docs_开发规范/01_API开发规范.md) - API 权限规范
- [安全规范](../../docs_开发规范/09_安全规范.md) - 安全开发规范
