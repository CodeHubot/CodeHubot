# 登录登出机制

## 概述

CodeHubot 平台采用基于 JWT（JSON Web Token）的无状态认证机制，支持多种用户角色（管理员、教师、学生、独立用户）的统一登录体系。

## 登录流程

### 1. 用户登录

#### 登录方式

系统支持以下登录方式：

1. **邮箱 + 密码**
2. **用户名 + 密码**
3. **机构登录**（学校/渠道账号 + 密码）

#### 登录流程图

```
客户端                    后端服务器                   数据库
  |                          |                          |
  |--1. POST /api/auth/login->|                          |
  |   {email/username,pwd}    |                          |
  |                          |--2. 查询用户------------->|
  |                          |<-3. 返回用户信息----------|
  |                          |                          |
  |                          |--4. 验证密码             |
  |                          |   (bcrypt/pbkdf2)        |
  |                          |                          |
  |                          |--5. 生成 JWT Token       |
  |                          |   - access_token         |
  |                          |   - refresh_token        |
  |                          |                          |
  |<-6. 返回登录响应---------|                          |
  |   {access_token,          |                          |
  |    refresh_token,         |                          |
  |    user_info}             |                          |
  |                          |                          |
  |--7. 存储到 localStorage   |                          |
```

#### 后端实现

**文件位置**: `backend/app/api/auth.py`

```python
@router.post("/login", response_model=LoginResponse)
async def login(login_data: UserLogin, db: Session = Depends(get_db)):
    """用户登录 - 支持用户名或邮箱登录"""
    
    # 1. 查找用户（支持用户名或邮箱）
    user = db.query(User).filter(
        (User.email == login_identifier) | 
        (User.username == login_identifier)
    ).first()
    
    # 2. 验证用户存在且未被禁用
    if not user or not user.is_active:
        raise HTTPException(status_code=401, detail="用户名或密码错误")
    
    # 3. 验证密码
    if not verify_password(login_data.password, user.password_hash):
        raise HTTPException(status_code=401, detail="用户名或密码错误")
    
    # 4. 生成 Token
    access_token = create_access_token(
        data={"sub": str(user.id), "type": "access"}
    )
    refresh_token = create_refresh_token(
        data={"sub": str(user.id)}
    )
    
    # 5. 更新最后登录时间
    user.last_login = get_beijing_time_naive()
    db.commit()
    
    # 6. 返回登录响应
    return {
        "access_token": access_token,
        "refresh_token": refresh_token,
        "token_type": "bearer",
        "user": user
    }
```

#### 前端实现

**文件位置**: `frontend/src/modules/pbl/admin/views/AdminLogin.vue`

```javascript
// 登录函数
const handleLogin = async () => {
  try {
    const response = await post('/auth/login', {
      email: loginForm.username,  // 可以是用户名或邮箱
      password: loginForm.password
    })
    
    // 存储 Token 和用户信息
    localStorage.setItem('admin_access_token', response.data.access_token)
    localStorage.setItem('admin_refresh_token', response.data.refresh_token)
    localStorage.setItem('admin_user_info', JSON.stringify(response.data.user))
    
    // 跳转到后台首页
    router.push('/admin/dashboard')
    
    ElMessage.success('登录成功')
  } catch (error) {
    ElMessage.error(error.message || '登录失败')
  }
}
```

### 2. 密码加密

系统使用双重密码保护机制：

#### 加密流程

```
原始密码
   ↓
SHA256 预处理 (解决 bcrypt 72字节限制)
   ↓
bcrypt 哈希 (加盐、慢速哈希)
   ↓
存储到数据库
```

#### 实现代码

**文件位置**: `backend/app/core/security.py`

```python
def _preprocess_password(password: str) -> str:
    """预处理密码以适应 bcrypt 的 72 字节限制"""
    return hashlib.sha256(password.encode('utf-8')).hexdigest()

def get_password_hash(password: str) -> str:
    """生成密码哈希"""
    preprocessed = _preprocess_password(password)
    return pwd_context.hash(preprocessed)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """验证密码"""
    preprocessed = _preprocess_password(plain_password)
    if pwd_context.verify(preprocessed, hashed_password):
        return True
    # 兼容旧密码（未预处理的）
    return pwd_context.verify(plain_password, hashed_password)
```

#### 密码算法

- **主算法**: bcrypt（推荐用于新密码）
- **兼容算法**: pbkdf2_sha256（兼容 CodeHubot-PBL 旧系统）
- **预处理**: SHA256（支持任意长度密码）

### 3. Token 验证

每个需要认证的 API 请求都会携带 access_token 进行验证。

#### 请求头格式

```http
GET /api/devices HTTP/1.1
Host: api.example.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

#### 后端验证

**文件位置**: `backend/app/core/deps.py`

```python
async def get_current_user(
    token: str = Depends(oauth2_scheme), 
    db: Session = Depends(get_db)
) -> User:
    """获取当前用户"""
    
    # 1. 验证 Token
    payload = verify_token(token, token_type="access")
    user_id = payload.get("sub")
    
    # 2. 查询用户
    user = db.query(User).filter(User.id == int(user_id)).first()
    if not user:
        raise HTTPException(status_code=401, detail="用户不存在")
    
    # 3. 检查用户状态
    if not user.is_active:
        raise HTTPException(status_code=403, detail="账户已被禁用")
    
    return user
```

#### 前端自动添加

**文件位置**: `frontend/src/utils/request.js`

```javascript
// 请求拦截器 - 自动添加 Token
request.interceptors.request.use(
  config => {
    const token = localStorage.getItem('admin_access_token') || 
                  localStorage.getItem('access_token')
    
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    
    return config
  }
)
```

## 登出流程

### 1. 前端登出

```javascript
const handleLogout = () => {
  // 1. 清除本地存储的 Token
  localStorage.removeItem('admin_access_token')
  localStorage.removeItem('admin_refresh_token')
  localStorage.removeItem('admin_user_info')
  
  // 2. 跳转到登录页
  router.push('/admin/login')
  
  ElMessage.success('已退出登录')
}
```

### 2. Token 失效处理

#### 响应拦截器

**文件位置**: `frontend/src/utils/request.js`

```javascript
request.interceptors.response.use(
  response => response,
  error => {
    if (error.response?.status === 401) {
      // Token 失效，清除并跳转登录
      localStorage.removeItem('admin_access_token')
      localStorage.removeItem('access_token')
      router.push('/login')
      ElMessage.error('登录已过期，请重新登录')
    }
    return Promise.reject(error)
  }
)
```

## 多角色登录

### 支持的角色类型

| 角色 | 表字段值 | 说明 | 登录入口 |
|-----|---------|------|---------|
| 管理员 | `admin` | 系统管理员 | `/admin/login` |
| 教师 | `teacher` | 学校教师 | `/teacher/login` |
| 学生 | `student` | 学校学生 | `/student/login` |
| 渠道 | `channel` | 渠道管理员 | `/channel/login` |
| 独立用户 | `individual` | 个人用户 | `/login` |

### Token 中的角色信息

```json
{
  "sub": "12345",           // 用户 ID
  "type": "access",         // Token 类型
  "role": "admin",          // 用户角色
  "exp": 1735401600         // 过期时间
}
```

### 角色专用登录 API

不同角色有独立的登录接口：

```python
# 管理员登录
POST /api/pbl/admin/login

# 教师登录
POST /api/pbl/teacher/login

# 学生登录
POST /api/pbl/student/login

# 渠道登录
POST /api/pbl/channel/login

# 通用登录（独立用户）
POST /api/auth/login
```

## 会话管理

### Token 有效期

```python
# backend/app/core/config.py
class Settings:
    access_token_expire_minutes: int = 60 * 24      # 24小时
    refresh_token_expire_minutes: int = 60 * 24 * 7 # 7天
```

### Token 刷新

当 `access_token` 即将过期时，使用 `refresh_token` 获取新的 `access_token`：

```javascript
// 刷新 Token
const refreshToken = async () => {
  const refresh_token = localStorage.getItem('admin_refresh_token')
  
  const response = await post('/auth/refresh', {
    refresh_token
  })
  
  // 更新 access_token
  localStorage.setItem('admin_access_token', response.data.access_token)
}
```

## 安全措施

### 1. 密码安全

- ✅ 使用 bcrypt 加密（自动加盐）
- ✅ SHA256 预处理（防止超长密码攻击）
- ✅ 慢速哈希（防止暴力破解）
- ✅ 密码长度限制（6-128 字符）

### 2. Token 安全

- ✅ HTTPS 传输（生产环境必须）
- ✅ HttpOnly Cookie（可选，防止 XSS）
- ✅ 短期 access_token（24小时）
- ✅ 长期 refresh_token（7天）
- ✅ Token 类型验证

### 3. 防护措施

- ✅ 登录失败不暴露具体原因（"用户名或密码错误"）
- ✅ 账户禁用检查
- ✅ CORS 限制
- ✅ 请求超时设置

## 常见问题

### 1. Token 过期如何处理？

**自动刷新方案**:

```javascript
// 响应拦截器中自动刷新
request.interceptors.response.use(
  response => response,
  async error => {
    const originalRequest = error.config
    
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true
      
      try {
        // 刷新 Token
        const newToken = await refreshToken()
        
        // 重试原请求
        originalRequest.headers.Authorization = `Bearer ${newToken}`
        return request(originalRequest)
      } catch {
        // 刷新失败，跳转登录
        router.push('/login')
      }
    }
    
    return Promise.reject(error)
  }
)
```

### 2. 如何实现"记住我"功能？

```javascript
// 登录时保存记住状态
if (rememberMe) {
  // 使用更长的过期时间
  localStorage.setItem('remember', 'true')
} else {
  // 使用 sessionStorage（关闭浏览器失效）
  sessionStorage.setItem('access_token', token)
}
```

### 3. 多设备登录如何管理？

当前实现为**无状态 Token**，支持多设备同时登录。如需单设备登录：

1. 数据库记录最新 Token 版本号
2. Token 中包含版本号
3. 验证时检查版本号是否匹配

## 相关文档

- [Token管理](./Token管理.md) - JWT Token 详细说明
- [权限管理体系](./权限管理体系.md) - 角色权限控制
- [API开发规范](../../docs_开发规范/01_API开发规范.md) - API 认证规范
