# 登录登出机制

## 概述

CodeHubot 平台采用基于 JWT（JSON Web Token）的无状态认证机制，支持多种用户角色（管理员、教师、学生、独立用户）的统一登录体系。

## 登录流程

### 1. 用户登录

#### 登录方式

系统支持以下登录方式：

1. **邮箱 + 密码**
2. **用户名 + 密码**

#### 登录流程图

```
客户端                    后端服务器                   数据库
  |                          |                          |
  |--1. POST /api/auth/login->|                          |
  |   {email/username,pwd}    |                          |
  |                          |--2. 查询用户------------->|
  |                          |<-3. 返回用户信息----------|
  |                          |                          |
  |                          |--4. 验证密码             |
  |                          |   (bcrypt/pbkdf2)        |
  |                          |                          |
  |                          |--5. 生成 JWT Token       |
  |                          |   - access_token         |
  |                          |   - refresh_token        |
  |                          |                          |
  |<-6. 返回登录响应---------|                          |
  |   {access_token,          |                          |
  |    refresh_token,         |                          |
  |    user_info}             |                          |
  |                          |                          |
  |--7. 存储到 localStorage   |                          |
```

#### 后端实现

**文件位置**: `backend/app/api/auth.py`

```python
@router.post("/login", response_model=LoginResponse)
async def login(login_data: UserLogin, db: Session = Depends(get_db)):
    """用户登录 - 支持用户名或邮箱登录"""
    
    # 1. 查找用户（支持用户名或邮箱）
    user = db.query(User).filter(
        (User.email == login_identifier) | 
        (User.username == login_identifier)
    ).first()
    
    # 2. 验证用户存在且未被禁用
    if not user or not user.is_active:
        raise HTTPException(status_code=401, detail="用户名或密码错误")
    
    # 3. 验证密码
    if not verify_password(login_data.password, user.password_hash):
        raise HTTPException(status_code=401, detail="用户名或密码错误")
    
    # 4. 生成 Token
    access_token = create_access_token(
        data={"sub": str(user.id), "type": "access"}
    )
    refresh_token = create_refresh_token(
        data={"sub": str(user.id)}
    )
    
    # 5. 更新最后登录时间
    user.last_login = get_beijing_time_naive()
    db.commit()
    
    # 6. 返回登录响应
    return {
        "access_token": access_token,
        "refresh_token": refresh_token,
        "token_type": "bearer",
        "user": user
    }
```

#### 前端实现

**文件位置**: `frontend/src/views/Login.vue`

```javascript
// 登录函数
const handleLogin = async () => {
  try {
    const response = await post('/auth/login', {
      email: loginForm.username,  // 可以是用户名或邮箱
      password: loginForm.password
    })
    
    // 存储 Token 和用户信息
    localStorage.setItem('admin_access_token', response.data.access_token)
    localStorage.setItem('admin_refresh_token', response.data.refresh_token)
    localStorage.setItem('admin_user_info', JSON.stringify(response.data.user))
    
    // 跳转到后台首页
    router.push('/admin/dashboard')
    
    ElMessage.success('登录成功')
  } catch (error) {
    ElMessage.error(error.message || '登录失败')
  }
}
```

### 2. 密码加密

系统使用双重密码保护机制：

#### 加密流程

```
原始密码
   ↓
SHA256 预处理 (解决 bcrypt 72字节限制)
   ↓
bcrypt 哈希 (加盐、慢速哈希)
   ↓
存储到数据库
```

#### 实现代码

**文件位置**: `backend/app/core/security.py`

```python
def _preprocess_password(password: str) -> str:
    """预处理密码以适应 bcrypt 的 72 字节限制"""
    return hashlib.sha256(password.encode('utf-8')).hexdigest()

def get_password_hash(password: str) -> str:
    """生成密码哈希"""
    preprocessed = _preprocess_password(password)
    return pwd_context.hash(preprocessed)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """验证密码"""
    preprocessed = _preprocess_password(plain_password)
    if pwd_context.verify(preprocessed, hashed_password):
        return True
    # 兼容旧密码（未预处理的）
    return pwd_context.verify(plain_password, hashed_password)
```

#### 密码算法

- **主算法**: bcrypt（推荐用于新密码）
- **预处理**: SHA256（支持任意长度密码）

### 3. Token 验证

每个需要认证的 API 请求都会携带 access_token 进行验证。

#### 请求头格式

```http
GET /api/devices HTTP/1.1
Host: api.example.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

#### 后端验证

**文件位置**: `backend/app/core/deps.py`

```python
async def get_current_user(
    token: str = Depends(oauth2_scheme), 
    db: Session = Depends(get_db)
) -> User:
    """获取当前用户"""
    
    # 1. 验证 Token
    payload = verify_token(token, token_type="access")
    user_id = payload.get("sub")
    
    # 2. 查询用户
    user = db.query(User).filter(User.id == int(user_id)).first()
    if not user:
        raise HTTPException(status_code=401, detail="用户不存在")
    
    # 3. 检查用户状态
    if not user.is_active:
        raise HTTPException(status_code=403, detail="账户已被禁用")
    
    return user
```

#### 前端自动添加

**文件位置**: `frontend/src/utils/request.js`

```javascript
// 请求拦截器 - 自动添加 Token
request.interceptors.request.use(
  config => {
    const token = localStorage.getItem('admin_access_token') || 
                  localStorage.getItem('access_token')
    
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    
    return config
  }
)
```

## 登出流程

### 1. 前端登出

```javascript
const handleLogout = () => {
  // 1. 清除本地存储的 Token
  localStorage.removeItem('admin_access_token')
  localStorage.removeItem('admin_refresh_token')
  localStorage.removeItem('admin_user_info')
  
  // 2. 跳转到登录页
  router.push('/admin/login')
  
  ElMessage.success('已退出登录')
}
```

### 2. Token 失效处理

#### 响应拦截器

**文件位置**: `frontend/src/utils/request.js`

```javascript
request.interceptors.response.use(
  response => response,
  error => {
    if (error.response?.status === 401) {
      // Token 失效，清除并跳转登录
      localStorage.removeItem('admin_access_token')
      localStorage.removeItem('access_token')
      router.push('/login')
      ElMessage.error('登录已过期，请重新登录')
    }
    return Promise.reject(error)
  }
)
```

## 多角色登录

### 支持的角色类型

| 角色 | 表字段值 | 说明 | 登录入口 |
|-----|---------|------|---------|
| 管理员 | `admin` | 系统管理员 | `/admin/login` |
| 教师 | `teacher` | 学校教师 | `/teacher/login` |
| 学生 | `student` | 学校学生 | `/student/login` |
| 渠道 | `channel` | 渠道管理员 | `/channel/login` |
| 独立用户 | `individual` | 个人用户 | `/login` |

### Token 中的角色信息

```json
{
  "sub": "12345",           // 用户 ID
  "type": "access",         // Token 类型
  "role": "admin",          // 用户角色
  "exp": 1735401600         // 过期时间
}
```

### 通用登录 API

所有用户使用统一的登录接口：

```python
# 通用登录
POST /api/auth/login
```

## 会话管理

### Token 有效期

```python
# backend/app/core/config.py
class Settings:
    access_token_expire_minutes: int = 60 * 24      # 24小时
    refresh_token_expire_minutes: int = 60 * 24 * 7 # 7天
```

### Token 刷新

当 `access_token` 即将过期时，使用 `refresh_token` 获取新的 `access_token`：

```javascript
// 刷新 Token
const refreshToken = async () => {
  const refresh_token = localStorage.getItem('admin_refresh_token')
  
  const response = await post('/auth/refresh', {
    refresh_token
  })
  
  // 更新 access_token
  localStorage.setItem('admin_access_token', response.data.access_token)
}
```

## 安全措施

### 1. 密码安全

- ✅ 使用 bcrypt 加密（自动加盐）
- ✅ SHA256 预处理（防止超长密码攻击）
- ✅ 慢速哈希（防止暴力破解）
- ✅ 密码长度限制（6-128 字符）

### 2. Token 安全

- ✅ HTTPS 传输（生产环境必须）
- ✅ HttpOnly Cookie（可选，防止 XSS）
- ✅ 短期 access_token（24小时）
- ✅ 长期 refresh_token（7天）
- ✅ Token 类型验证

### 3. 防护措施

- ✅ 登录失败不暴露具体原因（"用户名或密码错误"）
- ✅ 账户禁用检查
- ✅ CORS 限制
- ✅ 请求超时设置
- ✅ **登录验证码**（防止暴力破解）

### 4. 登录验证码（防暴力破解）

#### 功能说明

系统实现了**登录失败3次后强制验证码**机制，有效防止密码暴力破解攻击。

#### 触发机制

```
登录尝试                验证流程                  结果
   ↓                       ↓                       ↓
第1-2次失败          正常密码验证            提示剩余机会
   ↓                       ↓                       ↓
第3次失败            显示验证码输入框         强制验证码
   ↓                       ↓                       ↓
后续尝试             验证码 + 密码验证        必须输入验证码
   ↓                       ↓                       ↓
登录成功 或 1小时后    清除失败记录           恢复正常登录
```

#### API 接口

**1. 获取验证码图片**

```http
GET /api/auth/captcha?identifier={用户标识}

Response: PNG 图片
Content-Type: image/png
```

**2. 查询登录失败次数**

```http
GET /api/auth/login-attempts/{identifier}

Response:
{
  "code": 200,
  "data": {
    "attempts": 2,
    "needs_captcha": false,
    "threshold": 3
  }
}
```

**3. 登录接口（支持验证码）**

```http
POST /api/auth/login

Request Body:
{
  "email": "username or email",
  "password": "password",
  "captcha_code": "AB3C"  // 失败3次后必填
}
```

#### 前端集成示例

```javascript
// 检查是否需要验证码
async function checkLoginAttempts() {
  if (!username) return
  
  const response = await fetch(
    `/api/auth/login-attempts/${encodeURIComponent(username)}`
  )
  const result = await response.json()
  
  if (result.data.needs_captcha) {
    // 显示验证码输入框
    showCaptcha.value = true
    // 加载验证码图片
    captchaUrl.value = `/api/auth/captcha?identifier=${username}&t=${Date.now()}`
  }
}

// 登录处理
async function handleLogin() {
  try {
    await login({
      email: username,
      password: password,
      captcha_code: captchaCode  // 如需要
    })
    
    // 登录成功
    router.push('/')
  } catch (error) {
    // 检查错误信息，可能需要显示验证码
    if (error.message.includes('验证码')) {
      await checkLoginAttempts()
    }
    
    // 刷新验证码
    if (showCaptcha.value) {
      captchaUrl.value = `/api/auth/captcha?identifier=${username}&t=${Date.now()}`
      captchaCode = ''
    }
  }
}
```

#### 验证码特性

| 特性 | 说明 |
|-----|------|
| 触发条件 | 登录失败 3 次 |
| 验证码长度 | 4 位字符 |
| 字符集 | A-Z + 2-9（排除易混淆字符） |
| 有效期 | 5 分钟 |
| 使用次数 | 一次性（验证后立即失效） |
| 大小写 | 不区分 |
| 失败记录 | 1 小时后自动重置 |
| 图片格式 | PNG，120x40px，2-3KB |
| 干扰处理 | 干扰线 + 噪点 + 模糊 |

#### 安全优势

1. **防暴力破解** - 限制连续尝试次数，增加破解成本
2. **用户友好** - 前2次失败不影响用户体验
3. **自动重置** - 1小时后或登录成功自动清除记录
4. **防 OCR 识别** - 含干扰线、噪点和模糊处理
5. **一次性使用** - 验证后立即失效，无法重用
6. **不泄露信息** - 不暴露用户是否存在

#### 实现文件

**后端**:
- `backend/app/utils/captcha.py` - 验证码生成和管理
- `backend/app/api/auth.py` - 登录接口集成
- `backend/app/schemas/user.py` - Schema 定义

**前端**:
- `frontend/src/views/Login.vue` - 通用登录页
- `frontend/src/modules/device/views/Login.vue` - Device 登录页

#### 配置说明

```python
# backend/app/api/auth.py
LOGIN_ATTEMPT_THRESHOLD = 3  # 失败次数阈值，默认3次

# backend/app/utils/captcha.py
expire_minutes = 5           # 验证码有效期，默认5分钟
timedelta(hours=1)          # 失败记录保留时间，默认1小时
```

## 常见问题

### 1. Token 过期如何处理？

**自动刷新方案**:

```javascript
// 响应拦截器中自动刷新
request.interceptors.response.use(
  response => response,
  async error => {
    const originalRequest = error.config
    
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true
      
      try {
        // 刷新 Token
        const newToken = await refreshToken()
        
        // 重试原请求
        originalRequest.headers.Authorization = `Bearer ${newToken}`
        return request(originalRequest)
      } catch {
        // 刷新失败，跳转登录
        router.push('/login')
      }
    }
    
    return Promise.reject(error)
  }
)
```

### 2. 如何实现"记住我"功能？

```javascript
// 登录时保存记住状态
if (rememberMe) {
  // 使用更长的过期时间
  localStorage.setItem('remember', 'true')
} else {
  // 使用 sessionStorage（关闭浏览器失效）
  sessionStorage.setItem('access_token', token)
}
```

### 3. 多设备登录如何管理？

当前实现为**无状态 Token**，支持多设备同时登录。如需单设备登录：

1. 数据库记录最新 Token 版本号
2. Token 中包含版本号
3. 验证时检查版本号是否匹配

## 相关文档

- [Token管理](./Token管理.md) - JWT Token 详细说明
- [权限管理体系](./权限管理体系.md) - 角色权限控制
- [API开发规范](../../docs_开发规范/01_API开发规范.md) - API 认证规范
